import {Push, Pull, MessageLike} from "zeromq";
import {sleep} from "../functions/sleep";
import {prisma} from "./prisma";
import {GPT3} from "../functions/gpt";
import dayjs from "dayjs";
import {Component, processing_templates} from "@prisma/client";

const pushSocket = new Push();
const pullSocket = new Pull();

export class ZeroMessage {
    public readonly article_id: string
    public readonly api_key: string

    constructor(articleId: string, apiKey: string) {
        this.article_id = articleId;
        this.api_key = apiKey;
    }

    toString(): string {
        return JSON.stringify({
            article_id: this.article_id,
            api_key: this.api_key,
        })
    }

    static parse(payload: Buffer | string) {
        const {article_id, api_key} = JSON.parse(payload.toString());
        return new ZeroMessage(article_id, api_key)
    }
}

export async function push(message: ZeroMessage): Promise<void> {
    if (!pushSocket.writable) {
        await pushSocket.bind("tcp://*:7777");
    }

    await pushSocket.send(message.toString());
}

// todo:
// potential: finish_reason
//
// completed: The conversation was completed successfully and a satisfactory response was generated by the API.
// timeout: The API failed to generate a response within the given time limit.
// incomplete: The API generated a response, but it was incomplete or not satisfactory.
// model_failure: The API failed to generate a response due to an internal error or model failure.
// technical_issues: The API was unable to complete the request due to technical issues, such as network connectivity problems or server downtime.
// user_error: The request failed because of an error on the user's side, such as invalid input or incorrect authentication credentials.
// permission_denied: The request was denied due to insufficient permissions or incorrect API key.
// unavailable: The API is currently unavailable or undergoing maintenance.

function getCommand(
    processing_template: (processing_templates & { text: { value: string } | null, header: { value: string } | null, code: { value: string } | null }),
    component: Component
): string {
    if (processing_template.text && component.xpath.some(tag => ["p", "blockquote", "li"].includes(tag))) {
        return processing_template.text.value
    } else if (processing_template.code && component.xpath.some(tag => ["pre", "code"].includes(tag))) {
        return processing_template.code.value
    } else if (processing_template.header && component.xpath.some(tag => ["h1", "h2", "h3", "h4", "h5", "h6"].includes(tag))) {
        return processing_template.header.value
    }
    return '';
}

export async function pull(): Promise<void> {
    pullSocket.connect("tcp://localhost:7777");

    await sleep(500);

    const articles = await prisma.articles.findMany({
        where: {
            state: 'queued',
            user: {
                gpt3_api_key: {
                    isSet: true,
                    not: ''
                }
            }
        },
        include: {
            user: true
        }
    });

    for (const article of articles) {
        await push(new ZeroMessage(article.id, article.user.gpt3_api_key ?? ''));
    }

    for await (const [articleIdBuffer] of pullSocket) {
        console.time("queue");
        const {article_id, api_key} = ZeroMessage.parse(articleIdBuffer);

        if(!api_key) {
            await prisma.articles.update({
                where: {id: article_id},
                data: {
                    state: 'new'
                }
            });
            continue;
        }

        const article = await prisma.articles.findUnique({
            where: {id: article_id}, include: {
                processing_template: {
                    include: {
                        text: {
                            select: {
                                value: true
                            }
                        },
                        header: {
                            select: {
                                value: true
                            }
                        },
                        code: {
                            select: {
                                value: true
                            }
                        }
                    }
                }
            }
        });

        if (!article || !article.processing_template) {
            return;
        }

        const client = new GPT3(api_key);

        for (const component of article.components) {
            const command = getCommand(article.processing_template, component);
            if (command.length) {
                const {
                    message,
                    finish_reason
                } = await client.ask(`${command}\n\n${component.text}`);
                console.log(`${command}\n\n${component.text}`.blue)
                console.log("[" + String(`${finish_reason}`.yellow) + "]" + String(`\t${message.content}`.green))
                component.versions.push({text: component.text, replaced_at: dayjs().toDate()});
                component.text = message.content;
                component.finish_reason = finish_reason;
            } else {
                // no process this paragraph
            }
        }

        await prisma.articles.update({
            where: {id: article_id},
            data: {
                components: article.components,
                state: 'verification'
            }
        });

        console.timeEnd("queue");
    }
}
